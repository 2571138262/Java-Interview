# Java多线程与并发-原理
## 一、synchronized
### 1、线程安全问题的主要诱因
* 存在共享数据（也成为临界资源）
* 存在多条线程共同操作这些共享数据
### 2、解决问题的根本方法：
#### 同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作

### 3、互斥锁的特性
#### （1）、互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时刻只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的原子性。
#### （2）、可见性：必须确保在锁释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致
#### （3）、synchronized 锁的不是代码，锁的都是对象

### 4、根据获取的锁的分类 ：获取对象锁和获取类锁
#### （1）、获取对象锁的两种用法
##### ①、同步代码块（synchronized(this), synchronized(类实例对象)）, 锁是小括号()中的实例对象。
##### ②、同步非静态方法（synchronized method），锁时当前对象的实例对象

#### （2）、获取类锁的两种方法
##### ①、同步代码块（synchronized (类,class)），锁时小括号 () 中的类对象( Class对象 )。
##### ②、同步静态方法（synchronized static method）,锁时当前对象的类对象( Class对象)

### 5、对象锁和类锁的总结
#### 1、有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块；
#### 2、若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞
#### 3、若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞，
#### 4、若锁住的是同一个对象，一个线程在访问对象的同步代码块式，另一个访问对象同步方法的线程会被阻塞，反之亦然。
#### 5、同一个类的不同对象的对象锁互不干扰
#### 6、类锁由于也是一种特殊的对象锁，因此表现和上述1、2、3、4、一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁，将会是同步的
#### 7、类锁和对象锁互不干扰


## 一、synchronized底层实现原理
### 1、实现synchronized的基础
* Java对象头
* Monitor
### 2、对象在内存中的布局（分为三块区域）
* 对象头
* 实例数据
* 对齐填充

### 3、对象头结构
* Mark Word:是实现轻量级锁和偏向锁的关键
![Image](https://github.com/2571138262/Java-Interview/tree/master/images-folder/duixiangtoujiegou.jpg)

#### （1）、Mark Word 
* 由于对象头信息是与对象自身定义的没有关系的额外存储成本，因此考虑JVM的空间效率，Mark Word 被设计成为非固定的数据结构，
以便存储更多的有效数据，它会根据对象本身的状态，复用自己的存储空间
![Image](https://github.com/2571138262/Java-Interview/tree/master/images-folder/MardWord.jpg)

### 4、Monitor : 每个Java对象天生自带了一把看不见的锁，它叫做内部锁，或者monitor锁，Monitor也称为管程或者监视器锁，可以理解同步工具，也可以描述为一种同步机制
![Image](https://github.com/2571138262/Java-Interview/tree/master/images-folder/MardWord.jpg)
* 重量级锁: 也就是通常说的Synchronized对象锁，锁的标识为是10，指针指向monitor对象的起始地址
* 在Java虚拟机中，monitor是由hospot虚拟机实现的，是由C++编写的 

### 5、Monitor锁的竞争、获取与释放
![Image](https://github.com/2571138262/Java-Interview/tree/master/images-folder/monitorsuojingzhengyushifang.jpg)

### 6、什么是重入
###### 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入

