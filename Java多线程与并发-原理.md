# Java多线程与并发-原理
## 一、synchronized
### 1、线程安全问题的主要诱因
* 存在共享数据（也成为临界资源）
* 存在多条线程共同操作这些共享数据
### 2、解决问题的根本方法：
#### 同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再对共享数据进行操作

### 3、互斥锁的特性
#### （1）、互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性来实现多线程的协调机制，这样在同一时刻只有一个线程对需要同步的代码块（复合操作）进行访问。互斥性也称为操作的原子性。
#### （2）、可见性：必须确保在锁释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的（即在获得锁时应获得最新共享变量的值），否则另一个线程可能是在本地缓存的某个副本上继续操作，从而引起不一致
#### （3）、synchronized 锁的不是代码，锁的都是对象

### 4、根据获取的锁的分类 ：获取对象锁和获取类锁
#### （1）、获取对象锁的两种用法
##### ①、同步代码块（synchronized(this), synchronized(类实例对象)）, 锁是小括号()中的实例对象。
##### ②、同步非静态方法（synchronized method），锁时当前对象的实例对象

#### （2）、获取类锁的两种方法
##### ①、同步代码块（synchronized (类,class)），锁时小括号 () 中的类对象( Class对象 )。
##### ②、同步静态方法（synchronized static method）,锁时当前对象的类对象( Class对象)

### 5、对象锁和类锁的总结
#### 1、有线程访问对象的同步代码块时，另外的线程可以访问该对象的非同步代码块；
#### 2、若锁住的是同一个对象，一个线程在访问对象的同步代码块时，另一个访问对象的同步代码块的线程会被阻塞
#### 3、若锁住的是同一个对象，一个线程在访问对象的同步方法时，另一个访问对象同步方法的线程会被阻塞，
#### 4、若锁住的是同一个对象，一个线程在访问对象的同步代码块式，另一个访问对象同步方法的线程会被阻塞，反之亦然。
#### 5、同一个类的不同对象的对象锁互不干扰
#### 6、类锁由于也是一种特殊的对象锁，因此表现和上述1、2、3、4、一致，而由于一个类只有一把对象锁，所以同一个类的不同对象使用类锁，将会是同步的
#### 7、类锁和对象锁互不干扰


## 一、synchronized底层实现原理
### 1、实现synchronized的基础
* Java对象头
* Monitor
### 2、对象在内存中的布局（分为三块区域）
* 对象头
* 实例数据
* 对其填充

### 3、对象头结构
* Mark Word:
